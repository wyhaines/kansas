I want Kansas to be able to run using DBI, or using a native driver via
an adaptor, or even via dbi, but with an adaptor to facilitate special things
such as using hinting with Oracle.

And I want it to remain backwards compatible so that a:

KSDatabase.new('dbi:Mysql:foo','bar','bif')

still works.

So, there needs to be a set of rules to use when evaluating the connection
args.

Kansas should load a default set of rules, but should let them be manipulated.

Each "rule" is simple. It contains a block that accepts the args passed to new(), and the file to require should that block match.

Rules are inserted into an array, and select() called on that array, evaluating each of the blocks in turn.
If more than one rule matches, they are tried in order.  Exceptions are trapped, and the first to succede is the one that will be used.

Multiple databases should be mappable in Kansas at the same time, and each should live in its own unique namespace, somehow.

Use database name as part of the classname?  So a db foo with a table bar would have its real name as:

KSDatabse::Foo::Bar

But could be referred to via the shorthand of KSDatabase::Bar on a first come, first served basis?
i.e. if two different databases, each containing a table 'bar', are mapped, only the first table is accessible as KSDatabse::Bar.

For simple queries, would be nice to do this:

KSDatabase::Chemicals[173] # find record where primary key matches 173
KSDatabase::Chemicals.with_key(:chemical_name)['sodium hydroxide']
KSDatabase::Chemicals.with_key(:chemical_name).like '%hydroxide%'
KSDatabase::Chemicals.with_key(:manufacturer).with_key(:name)['Wyreth'] # chaining works when following relationships.
KSDatabase::Chemicals.select {chemical_name == 'sodium hydroxide'}
KSDatabase::Chemicals.select {manufacturer.name == 'Wyreth'}

-----

Adaptor code will be responsible for providing the services that Kansas requires.  The adaptor may provide those services through DBI or though other mechanisms.

The adaptor should implement some sort of delegation to the methods that implement it's interface to the datastore, allowing, at a minimum, direct submission of queries to the lower level database interface (whether this is DBI or a direct driver of some sort).

		Connection Management
	connected?	Is the adaptor connected to the db?
	ping		Check that the connection is live
	disconnect	Disconnect DB connection
	connect		Open connection
	reconnect	Disconnection, if necessary, then connect to the db again
	uptime
	vendor
	username
	password
	hostname
	dbname
	port
	driver

		DBI emulation; intended to support legacy apps; deprecated
	do		submit SQL for execution; no query data returned
	prepare		prepare a SQL statement for execution
	execute		execute a SQL statement
	select_one	submit and execute a SQL statement, returning a single row
	select_all	submit and execute a SQL statement, returning one or more rows in an array

		Query; query interface
	select		Accepts a Kansas query specification, makes it into something useable for the db, and submits to db, returning selection result
	count
	delete
	insert
	update
	escape		Takes a query and escapes dangerous characters in it, returning safe query
	query		Passthrough literal query to db; results returned in array

		Metadata
	tables		Returns list of tables in the database
	columns		Returns list of columns in a table
	indexes		Returns a list of indexes on a table

Kansas should provide a library of standard functions usable by the adaptors for creating SQL.

The default adaptor list should be autogenerated.  That is, it should list only those adaptors that are installed, and if a new one is installed, it should be autopopulated into the list.

The tricky thing here is positioning.  A driver consists of two parts.  The driver itself, and the rule.  The rule is a simple file that inserts an instance of KSAdaptorRule into a hash.
